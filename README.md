# Алгоритмы и структуры данных

## Структуры данных

Структуры данных играют важную роль в разработке. Одну и ту же задачу часто можно по разному решить, используя разные
стрктуры данных. Выбор одной структуры данных или другой не влияет на правильность программы, так как предполагается что
одна правильная реализация заменяется другой правильной реализацией. Но при выборе другой структуры данных, у неё может
быть инное временное отношение, в результате производительность программы может быть заметно ухудшена или улучшена. Вот
почему так важно выбрать правильную структуру данных для своей реализации.

В зависимости от реализации структуры данных можно разбить на 2 типа:

_Смежные струтуры данных_ - реализованы в виде непрерывных блоков памяти (массивы, матрицы, хэш-таблицы)

_Связные структуры данных_ - реализованы в отдельных блоках памяти, связанных с помощью указателей (списки, деревья)

### Массив

Структура данных смежного типа, так как записи данных в массивах имеют постоянный размер, поэтому не сложно найти любой
элемент по интексу. Недостаток постоянного размера массива - размер нельзя увеличить в процессе выполнения программы.
Можно подумать что этот недостаток можно решить объявлением массивов очень больших размеров, но это повлечёт за собой
чрезмерную затрату памяти.

На самом деле размер массива можно изменять во время работы программы с помощью _динамического выделения памяти._ Этот
процесс состоит из выделения памяти под новый непрерывный массив, копирования старого массива и возвращении памяти
старого массива в систему распределения памяти.

###### Плюсы:

- Постоянное время доступа по интексу;
- Локальность в памяти;
- Эффективное использование памяти, так как массивы содержат только данные.

###### Сложность:

- Доступ по инексу: O(1)
- Поиск элемента: O(n)
- Вставка элемента: O(n)
- Удаление элемента: O(n)

### Связный список

Связные списки как правило, могут быть однонаправленные - когда объект хранит ссылку на следующий объект, и
двунаправленные - в этом случае объект хранит ссылки на предыдущий и следующий объект.

Объект связного списка, как правило состоит из:

1) одного или нескольких полей для хранения данных
2) поле-указатель на следующий объект (и на предыдущий объект в двунаправленном списке)
3) указатель на начало структуры

###### Плюсы:

- невозможно переполнение, если только не переполнится сама память
- проще операция вставки и удаления
- при работе с записями проще происходит перемещение указателей, чем перемещение объекта

###### Минусы:

- необходимо дополнительное место для хранения указателей
- нет эффективного произвольного доступа к элементам

###### Сложность:

- Доступ к элементу: O(n)
- Поиск элемента: O(n)
- Вставка элемента: O(1)
- Удаление элемента: O(1)

### Стек

В стеке извлечение данных происходит в порядке LIFO (last in, first out). В алгоритмах такой порядок происходит, как
правило при выполнении рекурсивных операций. Стеки удобно применять в случаях, когда порядок извлечения данных не имеет
значения.

- push - операция вставки элемента в стек
- pop - операция извлечения верхнего объекта их стека

###### Сложность:

- Доступ к элементу: O(n)
- Поиск элемента: O(n)
- Вставка элемента: O(1)
- Удаление элемента: O(1)

### Очередь

Очередь поддерживает порядок извлечения FIFO (first in, first out). Очередь реализовывать несколько труднее, поэтому их
применение больше подходит тогда, когда нам важна очерёдность извлечения данных.

###### Сложность:

- Доступ к элементу: O(n)
- Поиск элемента: O(n)
- Вставка элемента: O(1)
- Удаление элемента: O(1)

### Дерево

Иерархичная структура данных, состящая из вершин (узлов) и рёбер, которые их соединяют. Главное отличие от графа - в
дереве не может быть цикла. Деревья широко используются в искусственном интеллекте и сложных алгоритмах для обеспечения
эффективного механизма хранения данных. Каждый узел может иметь бесконечное количество дочерних элементов в общем
дереве. Дерево является супер-множеством всех других деревьев.

##### Типы деревьев:
###### Бинарное дерево;

Бинарное дерево - это вид дерева, в котором для каждого родителя можно найти большинство двух детей. Дети известны как
левый ребенок и правый ребенок.

###### Бинарное дерево поиска;

Особенность дерева поиска заключается в алгоритме построения — значения вершин левого поддерева должны всегда
оказываться меньше или равны значению корневого узла, а правого – больше. Существует достаточно много алгоритмов работы
с древовидными структурами, в которых часто встречается понятие обхода (traversing) дерева или "прохода" по дереву. При
таком методе исследования дерева каждый узел посещается только один раз, а полный обход задает линейное упорядочивание
узлов, что позволяет упростить алгоритм, так как при этом можно использовать понятие "следующий" узел. т.е. узел стоящий
после данного при выбранном порядке обхода.

_**Обход дерева:**_
- Обход в глубину
    1. _Обход в прямом порядке_
       Каждый узел посещается ДО того как были посещены его потомки. 
       Для корня узна рекурсивно вызывается:
        - посетить узел
        - посетить левое поддерево
        - посетить правое поддерево
        
    2. _Симметричный обход_
       Посещается сначала левое поддерево, затем узел, затем правое поддерево
       Для корня дерева рекурсивно вызывается:
        - посетить левое поддерево
        - посетить узел
        - посетить правое поддерево

    3. _Обход в обратном порядке_
       Узлы посещаются снизу вверх
       Для корня дерева рекурсивно вызывается:
        - обойти левое поддерево
        - обойти правое поддерево
        - посетить узел

- Обход в ширину
    При обходе в ширину, узлы посещаются уроверь за уровнем. Каждый уровень обходится слева - направо. Для реализации
    используется Очередь. Таким образом, нужно добавить в контейнер сначала узел, затем его наследников, при этом узел
    далее должен быть обработан первым.
    Для корня дерева вызывается:
      - Поместим корень в очередь
      - если есть левый наследник - помещаем его в очередь для дальнейшей обработки
      - если есть правый наследник - помещаем его в очередь для дальнейшей обработки

- Обход бесконечных деревьев 
    Бывают ситуации, когда необходимо обработать бесконечное дерево. Дерево может генерироваться, когда мы обращаемся к 
    нему (например, мы обходим сайт, страницы которого генерируются сервером во время обращения), либо его размер просто 
    не известен (и возможно велик).
    Если дерево растёт _бесконечно в глубину_, то его можно обрабатывать, используя проход в ширину. То есть, известно, 
    что если спускаться вниз по ветви, то до конца мы не дойдём, но на данном уровне дерево имеет конечный размер.
    Если дерево растёт _бесконечно в ширину_, но при этом имеет конечную глубину (то есть, у узла не два наследника, а из
    бесконечно много), то можно использовать поиск в глубину.

###### N-арное дерево;

Максимальное число дочерних элементов в этом типе дерева, которое может иметь узел, равно N. Бинарное дерево - это
двухлетнее дерево, так как не более 2 дочерних элементов в каждом узле двоичного дерева. Полное N-арное дерево - это
дерево, в котором дочерние элементы узла равны 0 или N.

###### Красно-чёрное дерево;

Другой вид автобалансирующего дерева - красно-черный. Красно-черное имя дано потому, что красно-черное дерево имеет
красный или черный цвет на каждом узле в соответствии со свойствами красно-черного дерева. Поддерживает баланс леса.
Даже если это дерево не является полностью сбалансированным, операция поиска занимает всего O (log n) времени. Когда
новые узлы добавляются в красно-черное дерево, они снова поворачиваются, чтобы сохранить свойства красно-черного дерева.

###### AVL дерево;

Дерево AVL является бинарным деревом поиска с само-балансированием. АВЛ-дерево — это прежде всего двоичное дерево
поиска, ключи которого удовлетворяют стандартному свойству: ключ любого узла дерева не меньше любого ключа в левом
поддереве данного узла и не больше любого ключа в правом поддереве этого узла. Особенностью АВЛ-дерева является то, что
оно является сбалансированным в следующем смысле: для любого узла дерева высота его правого поддерева отличается от
высоты левого поддерева не более чем на единицу.

###### KD дерево;

Общая идея kd-деревьев заключается в разделении плоскости, содержащей объекты на части (прямоугольные области) таким
образом, что в каждой области содержится один объект. При этом, между областями можно выстроить иерархические
зависимости, за счет которых можно существенно повысить эффективность поиска. Существуют различные типы kd-деревьев,
отличающиеся выбором секущей плоскости. 

###### Префиксное дерево;

Структура данных, позволяющая хранить ассоциативный массив, ключами которого являются строки. Они обеспечивают быстрый
поиск и используются преимущественно для поиска слов в словаре, автодополнения в поисковых системах и даже для
IP-маршрутизации. Слова размещаются сверху вниз. Выделенные зеленым элементы показывают конец каждого слова.

###### R дерево;

Это другая пространственная структура данных, подходящая для геометрических объектов, которые нельзя разделить по
прямоугольным областям, ориентированным вдоль координатных осей, не разрезая их на части. На каждом уровне сечения
объекты разбиваются на меньшее количество прямоугольных областей(возможно, накладывающихся друг на друга), чтобы создать
удобные для поиска иерархические структуры, не разрезая объекты на части

###### Сложность:

- Доступ к элементу: O(log(n))
- Поиск элемента: O(log(n))
- Вставка элемента: O(log(n))
- Удаление элемента: O(log(n))

### Граф

Граф представляет собой набор узлов, соединенных друг с другом в виде сети. Узлы также называются вершинами. Пара (x, y)
называется ребром, которое указывает, что вершина x соединена с вершиной y. Ребро может содержать вес/стоимость,
показывая, сколько затрат требуется, чтобы пройти от x до y.

###### Виды графов:
- Ориентированные/неориентированные
- Взвешенные/невзвешенные
- Простые/слоные (наличие петель)

_**Обход графа:**_

- Обход в ширину _(Depth-First Search, DFS)_
  Идея заключается в том, что мы двигаемся от начальной вершины (точки, места) в определенном направлении (по
  определенному пути) до тех пор, пока не достигнем конца пути или пункта назначения (искомой вершины). Если мы достигли
  конца пути, но он не является пунктом назначения, то мы возвращаемся назад (к точке разветвления или расхождения
  путей) и идем по другому маршруту.


- Обход в глубину _(Breadth-First Search, BFS)_
  Вместо того, чтобы двигаться по определенному пути до конца, BFS предполагает движение вперед по одному соседу за раз.


### Словарь

Этот тип данных предоставляет доступ к данным по содержимому. Словарь применяется для хранения данных, которые можно
быстро найти в случае необходимости.

### Хеш-таблица

Хеширование – это процесс, используемый для уникальной идентификации объектов и хранения каждого из них в некотором
предварительно вычисленном уникальном индексе – ключе. При получении одинакового хэш значения для нескольких объектов -
происходит коллизия.

###### Способы устранения коллизий:

- _Применение цепочек_. Для этого хэш таблица реализуется ввиде массива из нескольких связных списков. Список с порядковым
  номером содержит все элементы, хэшированные в одно и то же значение. Таким образом, операции поиска, вставки и
  удаления сводятся к соответствующим операциям в связных списках.
  
- _Открытая адресация_. В этом случае хэш-таблица рализуется как массив ключей(а не корзин), каждый из которых
  инициализирован значением null. При вставке ключа выполняется проверка, свободна ли требуемая ячейка. Если свободна,
  то вставка выполняется. В противном случае нам нужно найти другое место, куда вставить данный ключ. Самый простой
  подход к определению альтернативного места для вставки называется последовательным исследованием (sequential probing).
  Этот метод заключается в том, что последовательно исследуются следующие ячейки таблицы, пока не будет найдена
  свободная, в которую и выполняется вставка. Если таблица не слишком заполнена, то последовательность смежных занятых
  ячеек должна быть довольно небольшой, и свободная ячейка должна находиться лишь в нескольких позициях от требуемой.
  Теперь для поиска определенного ключа нужно взять соответствующее хэш-значение и проверить, является ли его значение
  тем, какое нам нужно. Если да, то поиск заканчивается. В противном случае поиск продолжается в последовательности
  смежных ячеек, пока не будет найдено требуемое значение. Удаление из хэш-таблицы с открытой адресацией довольно
  сложная процедура, т. к. удаление одного элемента может разорвать цепочку вставок, вследствие чего некоторые элементы
  последовательности больше не будут доступны. Не остается иного выхода, кроме как выполнить повторную вставку всех
  элементов, следующих за удаленным.

###### Сложность:

- Поиск элемента: O(1)/O(n)
- Вставка элемента: O(1)/O(n)
- Удаление элемента: O(1)/O(n)